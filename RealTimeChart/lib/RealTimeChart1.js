//////////////////////////////////////////////////////////////////////////////
// GLG RealTimeChart example demonstrates how to use a custom chart widget 
// containing a toolbar allowing to scroll and zoom the chart, as well
// as change the time interval on the X axis for viewing the chart data. 
//
// DemoDataFeed.js supplies simulated data for animation. An application 
// should provide a custom implementation of LiveDataFeed.js to supply 
// real-time application data to the chart. Refer to README.txt for more
// information.
//
// Real-time data for the chart are quiried based on tags assigned to the
// plots in a chart. Tags are added to the ValueEntryPoint of each plot 
// in the drawing at design time, and a valid TagSource should be assigned 
// for each tag. Tag sources represent data source variables used to query 
// data for the plots and are used by the DataFeed object to query 
// real-time data for for the chart.
//////////////////////////////////////////////////////////////////////////////

// Get a handle to the GLG Toolkit library.
var GLG = new GlgToolkit();

// Debugging aid: uncomment the next line to throw an exception on a GLG error.
GLG.ThrowExceptionOnError( true, true, true );

/* stripchart.g displays a horizontal stripchart.
   Change to stripchart_vertical.g to display a vertical stripchart.
*/
var DrawingName = "/RealTimeChart/OpenGL/chart1.g";
var DrawingTitle = "RealTime Stripchart";

/* Is set to true, simulated demo data will be used for animation.
   Set to false to enable live application data generated by
   GetAppData().
*/
const RANDOM_DATA = true;

// Enable debuginng/diagnostics information.
const DEBUG = false;

/* If set to true, the application supplies time stamp for each data 
   sample explicitly in DataFeed.GetPlotPoint(). Otherwise, time stamp 
   is automatically generated by the chart using current time.
*/
var SUPPLY_TIME_STAMP = false;

// DataFeed object used for animation.
var DataFeed = null;  

// Top level viewport of the loaded drawing (GlgObject).
var MainViewport;

// Viewport containing the Chart oject.
var ChartVP = null;          /* GlgObject */

// Chart object inside ChartVP.
var Chart = null;

// An array of PlotInfo objects. Stores information about each plot in a chart.
var PlotArray = null;        /* PlotInfo[] */

// Number of plots.
var NumPlots = 3;            /* int */

// Number of Y axes.
var NumYAxes = 0;            /* int */

// Arrays storing low and high ranges for all Y axes.
var Low = null;             /* double[] */
var High = null;            /* double[] */

// Toolbar object inside the chart drawing.
var Toolbar = null;         /* GlgObject */

/* Contains a list of tag sources defined in the drawing, which are used by the 
   DataFeed object to query real-time data for the chart plots.
   The array is populated in CreateDataTagList(), and each element has
   a property 'tag_source'. 
*/
var DataTagList = null;   /* [] */

// Update interval in msec.
var UpdateInterval = 100;  

// Convenient time span constants.
const  ONE_MINUTE = 60;
const  ONE_HOUR   = 3600;
const  ONE_DAY    = 3600 * 24;
    
/* Prefill time interval, specifies amount of data to prefill in the 
   real time chart. 
*/
var PREFILL_SPAN = ONE_HOUR * 8;

/* Constants for scrolling the chart to the beginning or the end of 
   the time range.
*/
const DONT_CHANGE  = 0;
const MOST_RECENT  = 1;  /* Make the most recent data visible. */
const LEAST_RECENT = 2;  /* Make the least recent data visible.*/

// Index of the initial span to display.
var INIT_SPAN = 0;    

// Index of the currently displayed time span.
var SpanIndex = INIT_SPAN; 

var TimeSpan = 0;           // Time axis span in sec.

/* If set to true, the chart's data buffer is prefilled with historical data
   on start-up.
*/ 
var PrefillData = true;

// int: Current auto-scroll state: enabled(1) or disabled(0).
var AutoScroll = 1;

// int: Stored AutoScroll state to be restored if ZoomTo is aborted.
var StoredScrollState; 

// YAxis levels (thresholds).
var Levels = [ 
   { level: 1.0, color: { r:0.0, g:0.0, b:1.0 } },
   { level: 9.0, color: { r:1.0, g:0.0, b:0.0 } }
];

/* Coefficients for canvas resolution and text resolution. 
   These parameters will be adjusted for mobile devices with HiDPI displays
   in SetCanvasResolution().
*/
var CoordScale = 1;
var TextScale = 1;

// Set initial size of the drawing.
SetDrawingSize( false );

/* Increase canvas resolution for mobile devices. Changes CoordScale and
   TextScale.
*/
SetCanvasResolution();

/* Load misc. assets such as GLG scrollbars. When assets are loaded, 
   LoadDrawing callback is invoked that loads a GLG drawing defined by
   DrawingName variable.
*/
LoadAssets( LoadDrawing, null );

// Add DataFeed object which is used to animate the drawing with real-time data.
AddDataFeed();

////////////////////////////////////////////////////////////////////////////// 
// Load a GLG drawing from a file.
////////////////////////////////////////////////////////////////////////////// 
function LoadDrawing()
{
   /* Load a drawing from the specified drawing file. 
      The LoadCB callback will be invoked when the drawing has been loaded.
   */
   GLG.LoadWidgetFromURL( DrawingName, null, LoadCB, /*user data*/ null );
}

//////////////////////////////////////////////////////////////////////////////
function LoadCB( /*GlgObject*/ drawing, /*Object*/ user_data, 
                 /*String*/ path )
{
   if( drawing == null )
   {
      AppAlert( "Can't load drawing, check console message for details." );
      return;
   }
   
   var loader = document.getElementById( "loader_container" );
   if( loader )
     loader.parentNode.removeChild( loader );
    
   // Define the element in the HTML page to display the drawing.
   drawing.SetParentElement( "glg_area" );
    
   // Disable viewport border to use the border of the glg_area.
   drawing.SetDResource( "LineWidth", 0 );
    
   StartGlgChart( drawing );
}

//////////////////////////////////////////////////////////////////////////////
function StartGlgChart( /*GlgObject*/ drawing )
{
   MainViewport = drawing;

   // Adjust the drawing for mobile devices if needed.
   AdjustForMobileDevices();
        
   // Initialization before hierarchy setup.
   InitBeforeH();

   // Setup object hierarchy in the drawing.
   MainViewport.SetupHierarchy();

   // Initialization after hierarchy setup.
   InitAfterH();

   // Start dynamic updates.
   GetData();

   // Display the drawing in a web page.
   MainViewport.Update();
}

//////////////////////////////////////////////////////////////////////////////
// Initialization before hierarchy setup.
//////////////////////////////////////////////////////////////////////////////
function InitBeforeH()
{
   // Add Input and Trace callbacks.
   MainViewport.AddListener( GLG.GlgCallbackType.INPUT_CB, InputCallback );
   MainViewport.AddListener( GLG.GlgCallbackType.TRACE_CB, TraceCallback );
   
   // Retrieve object ID of the Toolbar viewport.
   Toolbar = MainViewport.GetResourceObject( "Toolbar" );
   if( Toolbar == null )
     AppAlert( "Toolbar object not found. " );
   // Retrieve ChartViewport object.
   ChartVP = MainViewport.GetResourceObject( "ChartViewport" );
   if( ChartVP == null )
   {
      AppAlert( "ChartViewport not found. " );
      return;
   }
   // Retrieve the Chart object.
   Chart = ChartVP.GetResourceObject( "Chart" );
   if( Chart == null )
   {
      AppAlert( "Chart object not found. " );
      return;
   }

   // Retrieve the number of plots defined in the drawing.
   NumPlots = Math.trunc( Chart.GetDResource( "NumPlots" ) );
    
   // Retrieve the number of Y axes defined in the drawing.
   NumYAxes = Math.trunc( Chart.GetDResource( "NumYAxes" ) );
   // Enable AutoScroll, both for the toggle button and the chart.
   ChangeAutoScroll( 1 );

   /* Set Chart Zoom mode. It was set and saved with the drawing, 
      but do it again programmatically just in case.
   */
   ChartVP.SetZoomMode( null, Chart, null, GLG.GlgZoomMode.CHART_ZOOM_MODE );
    
   // GAUGE CHART
   // MainViewport.SetDResource( "Dial1/High", 100.0 );
   // MainViewport.SetDResource( "Dial1/Low", 0 );
   /* Uncomment the line below to override XAxis label TimeFormat 
      defined in the drawing. "%T" displays time without a date.
   */
   //Chart.SetSResource( "XAxis/TimeFormat", "%T" );
}

//////////////////////////////////////////////////////////////////////////////
// Initialization after hierarchy setup.
//////////////////////////////////////////////////////////////////////////////
function InitAfterH()
{
   var plot, value_ep, time_ep, valid_ep; /* GlgObject */
   var tag_source;                        /* String */
   var i;                                 /* int */

   // Retreve the a group of plots from the chart.
   var plots = Chart.GetResourceObject( "Plots" );  /* GlgObject  */

   // Allocate PlotArray and store information for each plot. 
   PlotArray = [];

   /* Populate PlotArray with PlotInfo objects, storing information
      for each plot.
   */
   for( i=0; i<NumPlots; ++i )
   {
      plot = plots.GetElement( i ); 
      value_ep = plot.GetResourceObject( "ValueEntryPoint" );
      time_ep = plot.GetResourceObject( "TimeEntryPoint" );
      valid_ep = plot.GetResourceObject( "ValidEntryPoint" );

      if( value_ep.HasResourceObject( "TagObject" ) )
        tag_source = value_ep.GetSResource( "TagSource" );
      else
        tag_source = null;

      // Skip plots with invalid TagSource.        
      if( IsUndefined( tag_source ) )
      {
         AppAlert( "Invalid TagSource for Plot# " + i );
         continue;
      }

      // Add new plot record to PlotArray.
      PlotArray.push( new PlotInfo( plot, value_ep, time_ep, valid_ep,
                                    tag_source ) ); 
   }
   
   // Store valid tag sources in DataTagList array.
   CreateDataTagList();

   /* Store initial range for each Y axis to restore on zoom reset. 
      Assumes that plots are linked with the corresponding axes in the 
      drawing.
   */         
   Low = new Array( NumYAxes );    /* double[] */
   High = new Array( NumYAxes );   /* double[] */
    
   var axis_array = Chart.GetResourceObject( "YAxisGroup" ); /* GlgObject */
   for( i=0; i<NumYAxes; ++i )
   {
      var axis = axis_array.GetElement( i );   /* GlgObject */
      Low[i] = axis.GetDResource( "Low" );
      High[i] = axis.GetDResource( "High" );
   }
    
   // Set chart's time span on the X axis.
   SetChartSpan( SpanIndex );
    
   /* Prefill chart's history buffer with data for a specified number 
      of seconds.
   */
   if( PrefillData )
     FillChartHistory( PREFILL_SPAN );
}

//////////////////////////////////////////////////////////////////////////////
// Create DataFeed object used to animate the chart with data.
// Simulated data are provided by DemoDataFeed. The application should 
// provide a custom implementation of LiveDataFeed.js to supply real-time
// application data for the chart.
//////////////////////////////////////////////////////////////////////////////
function AddDataFeed()
{
   if( RANDOM_DATA )
   {
      DataFeed = new DemoDataFeed();
      console.log( "Using random DemoDataFeed." );
   }
   else
   {
      DataFeed = new LiveDataFeed();
      console.log( "Using LiveDataFeed." );
   }
}

//////////////////////////////////////////////////////////////////////////////
function CreateDataTagList()
{
   if( PlotArray == null || PlotArray.length == 0 )
   {
      DatatagList = null;
      return;
   }

   DataTagList = [];   /* String[] */
   for( var i=0; i<PlotArray.length; ++i )
   {
      // Store only valid tag sources, skipping unassigned tags.
      if( !IsUndefined( PlotArray[i].tag_source ) )
        DataTagList.push( { tag_source: PlotArray[i].tag_source } );
   }
}

////////////////////////////////////////////////////////////////////////////// 
// Pre-fill the graph's history buffer with data. 
////////////////////////////////////////////////////////////////////////////// 
function FillChartHistory( /*int*/ prefill_span )
{
   if( PlotArray == null || PlotArray.length == 0 )
     return;

   var current_time = GetCurrTime();   /* double */
    
   /* Fill the amount of data requested by the PREFILL_SPAN, up to the 
      available chart's buffer size defined in the drawing.
      Add an extra second to avoid rounding errors.
   */
   var num_seconds = prefill_span + 1;  /* int */
    
   var buffer_size =     /* int */
     Math.trunc( Chart.GetDResource( "BufferSize" ) );
   if( buffer_size < 1 )
     buffer_size = 1;
    
   var max_num_samples;   /* int */
   if( RANDOM_DATA )
   {
      // In random demo data mode, simulate data stored once per second.
      var samples_per_second = 1.0;   /* double */
      max_num_samples = Math.trunc( num_seconds * samples_per_second );
        
      if( max_num_samples > buffer_size )
        max_num_samples = buffer_size;
   }
   else
     max_num_samples = buffer_size;
    
   // Start and end time for the data query.
   var start_time = current_time - num_seconds;   /* double */
   var end_time = current_time;     /* double : Stop at the current time. */

   /* Obtain historical data for the plot based on the tag assigned
      to the plot's ValueEntryPoint.
   */
   for( var i=0; i<PlotArray.length; ++i )
     DataFeed.GetHistPlotData( PlotArray[i].tag_source, 
                               start_time, end_time, max_num_samples,
                               /*callback*/ PlotHistDataCB, 
                               /*user data*/ PlotArray[i].plot );
}

////////////////////////////////////////////////////////////////////////////// 
// Fills a plot with data from the provided data array.
// For increased performance of prefilling a chart with large quantities of
// data, the data are pushed into the plot using a low level API method
// AddPlotDataSample.
////////////////////////////////////////////////////////////////////////////// 
function PlotHistDataCB( /*PlotDataPoint[]*/ data_array, /*GlgObject*/ plot )
{
   if( data_array == null )
     return;

   var size = data_array.length;
   for( var i=0; i<size; ++i )
   {
      var data_point = data_array[i];   /* PlotDataPoint */
       
      // Using quick mode to speed up prefilling of the chart.
      plot.AddPlotDataSample( data_point.value, data_point.time_stamp,
                              data_point.value_valid, /*no marker*/ 0,
                              /*quick mode*/ true );
   }
}

//////////////////////////////////////////////////////////////////////////////
function GetData()
{
   if( DataFeed == null )
     return;

   /* Obtain new real-time data values for all plots in the chart
      and invoke GetDataCB callback when done. Tags assigned to the
      ValueEntryPoint of each plot represent data source variables
      to query real-time values for.
   */
   DataFeed.ReadData( DataTagList, GetDataCB /*callback*/, /*user data*/ null );
}

//////////////////////////////////////////////////////////////////////////
// Data query callback. It is invoked by the DataFeed after the new data 
// are received from the server.
//////////////////////////////////////////////////////////////////////////
function GetDataCB( new_data )
{
   // Push new data to the chart.
   UpdateChart( new_data );
    
   // Send new data query request.
   setTimeout( GetData, UpdateInterval );
}

//////////////////////////////////////////////////////////////////////////////
// Push new data into graphics. For each tag in new_data array, find a
// a record in PlotArray with a matching tag source, store the new value, 
// and push new value into graphics.  
//////////////////////////////////////////////////////////////////////////////
function UpdateChart( new_data )
{
   if( new_data == null || new_data.length == 0 )
   {
      AppInfo( "No new data received." );
      return;
   }

   for( var i=0; i<new_data.length; ++i )
   {
      /* Find a plot record in PlotArray that has a tag_source matching 
         new_data[i].tag_source.
      */
      var plot_record = LookupPlotArray( new_data[i].tag_source );

      // Plot record not found, don't use this data point.
      if( plot_record == null )
      {
         AppError( "Discarding data point, plot not found for TagSource = " 
                   + new_data[i].tag_source );
         continue;
      }

      var value = new_data[i].value;
      var time_stamp = new_data[i].time_stamp;
      var value_valid = DataFeed.IsValid( new_data[i].tag_source, value );

      // Push new data value into the chart plot using plot's entry points.
      plot_record.value_ep.SetDResource( null, value );
      plot_record.valid_ep.SetDResource( null, value_valid ? 1. : 0. );

      /* Push time stamp if provided. Otherwise, the chart will
         automatically use current time as a time stamp for the X axis.
      */
      if( time_stamp != null && SUPPLY_TIME_STAMP )
        plot_record.time_ep.SetDResource( null, time_stamp );
   }

   // Refresh display.
   MainViewport.Update();
}

//////////////////////////////////////////////////////////////////////////////
// Find a plot record in PlotArray which has a tag source matching
// the specified tag_source.
//////////////////////////////////////////////////////////////////////////////
function LookupPlotArray( /*String*/ tag_source )  /* PlotInfo */
{
   if( PlotArray == null )
     return null;

   for( var i=0; i<PlotArray.length; ++i )
   {
      if( PlotArray[i].tag_source == tag_source )
        return PlotArray[i];
   }

   return null; // not found.
}

//////////////////////////////////////////////////////////////////////////////
// Handle user interaction as needed.
//////////////////////////////////////////////////////////////////////////////
function InputCallback( viewport, message_obj )
{
   var origin = message_obj.GetSResource( "Origin" );
   var format = message_obj.GetSResource( "Format" );
   var action = message_obj.GetSResource( "Action" );
   var subaction = message_obj.GetSResource( "SubAction" );
    
   if( format == "Button" )
   {	 
      if( action !="Activate" &&         /* Not a push button */
          action != "ValueChanged" )     /* Not a toggle button */
        return;
        
      // Abort ZoomTo mode, if any.
      AbortZoomTo();
        
      if( origin == "ToggleAutoScroll" )
      {         
         /* Set Chart AutoScroll based on the ToggleAutoScroll toggle button 
            setting.
         */
         ChangeAutoScroll( -1 ); 
      }
      else if( origin == "ZoomTo" )
      {
         // Start ZoomTo operation.
         ChartVP.SetZoom( null, 't', 0.0 );  
      }
      else if( origin == "ZoomReset" )
      {         
         // Set initial time span and reset initial Y ranges.
         SetChartSpan( SpanIndex );  
         RestoreInitialYRanges();   
      }
      else if( origin == "ScrollBack" )
      {
         ChangeAutoScroll( 0 );
            
         // Scroll left by 1/3 of the span.
         ChartVP.SetZoom( null, 'l', 0.33 );
      }
      else if( origin == "ScrollForward" )
      {
         ChangeAutoScroll( 0 );
            
         // Scroll right by 1/3 of the span.
         ChartVP.SetZoom( null, 'r', 0.33 );
      }
      else if( origin == "ScrollBack2" )
      {
         ChangeAutoScroll( 0 );
            
         // Scroll left by a full span.
         ChartVP.SetZoom( null, 'l', 1.0 );
      }
      else if( origin == "ScrollForward2" )
      {
         ChangeAutoScroll( 0 );
            
         // Scroll right by a full span.
         ChartVP.SetZoom( null, 'r', 1.0 );
      }
      else if( origin == "ZoomIn" )
      {
         // Zoom in in Y direction.
         ChartVP.SetZoom( null, 'I', 1.5 );
      }
      else if( origin == "ZoomOut" )
      {
         // Zoom out in Y direction.
         ChartVP.SetZoom( null, 'O', 1.5 );
      }
      else if( origin == "ScrollToRecent" )
      {
         // Scroll to show most recent data.
         ScrollToDataEnd( MOST_RECENT, true );
      }
        
      viewport.Update();  //format = "Button"
   }

   else if( format == "Option" )
   {
      if( action != "Select" )
        return;

      // Abort ZoomTo mode, if any.
      AbortZoomTo();

      /* Handle events from the SpanSelector menu allowing to select time 
         interval for the X axis.
      */
      if( origin == "SpanSelector" )    /* Span change */
      { 
         SpanIndex =
           Math.trunc( message_obj.GetDResource( "SelectedIndex" ) );
            
         SetChartSpan( SpanIndex );
         RestoreInitialYRanges(); /* Restore in case the chart was zoomed.*/
            
         /* Scroll to show the recent data to avoid showing an empty chart
            if user scrolls too much into the future or into the past.
            Invoke ScrollToDataEnd() even if AutoScroll is True to 
            scroll ahead by a few extra seconds to show a few next updates
            without scrolling the chart.
         */
         var min_max =    /* GlgMinMax */
           Chart.GetChartDataExtent( null, /*x extent*/ true,
                                     /*query all samples*/ false );  
            
         if( min_max != null )
         {
            var first_time_stamp = min_max.min;   /* double */
            var last_time_stamp = min_max.max;    /* double */
            var displayed_time_end =    /* double */
              Chart.GetDResource( "XAxis/EndValue" );
                
            if( AutoScroll != 0 )
              ScrollToDataEnd( MOST_RECENT, true );
                
            else if( displayed_time_end >
                     last_time_stamp + GetExtraSeconds() )
              ScrollToDataEnd( MOST_RECENT, true );
                
            else if( displayed_time_end - TimeSpan <= first_time_stamp )
              ScrollToDataEnd( LEAST_RECENT, true );
                
            viewport.Update();
         }
      }
   }

   else if( format == "Chart" && action == "CrossHairUpdate" )
   {
      /* To avoid slowing down real-time chart updates, invoke Update() 
         to redraw cross-hair only if the chart is not updated fast 
         enough by the timer.
      */
      if( UpdateInterval > 100 )
        viewport.Update();         
   }          
  
   else if( action == "Zoom" )    // Zoom events
   {
      if( subaction == "ZoomRectangle" )
      {
         // Store AutoSCroll state to restore it if ZoomTo is aborted.
         StoredScrollState = AutoScroll;
            
         // Stop scrolling when ZoomTo action is started.
         ChangeAutoScroll( 0 );
      }
      else if( subaction == "End" )
      {
         /* No additional actions on finishing ZoomTo. The Y scrollbar 
            appears automatically if needed: it is set to GLG_PAN_Y_AUTO. 
            Don't resume scrolling: it'll scroll too fast since we zoomed 
            in. Keep it still to allow inspecting zoomed data.
         */
      }
      else if( subaction == "Abort" )
      {
         // Resume scrolling if it was on.
         ChangeAutoScroll( StoredScrollState ); 
      }
        
      viewport.Update();
   }
   else if( action == "Pan" )    // Pan events
   {
      // Place custom code to handle pan or drag events.
   }
}

//////////////////////////////////////////////////////////////////////////////
// A custom trace callback for the page; is used to obtain coordinates 
// of the mouse click.
//////////////////////////////////////////////////////////////////////////////
function TraceCallback( /*GlgObject*/ viewport, /*GlgTraceData*/ trace_info )
{
   // Process only events that occur in ChartViewport.
   if( !trace_info.viewport.Equals( ChartVP ) )
     return false;

   var x, y;        /* double */
    
   var event_type = trace_info.event_type;
   switch( event_type )
   {
    case GLG.GlgEventType.TOUCH_START:
      GLG.SetTouchMode();        /* Start dragging via touch events. */
      /* Fall through */
        
    case GLG.GlgEventType.TOUCH_MOVED:
      if( !GLG.GetTouchMode() )
        return;
    case GLG.GlgEventType.MOUSE_PRESSED:
    case GLG.GlgEventType.MOUSE_MOVED:
      x = trace_info.mouse_x * CoordScale;
      y = trace_info.mouse_y * CoordScale;
         
      /* COORD_MAPPING_ADJ is added to the cursor coordinates for precise
         pixel mapping.
      */
      x += GLG.COORD_MAPPING_ADJ;
      y += GLG.COORD_MAPPING_ADJ;
      break;

    default: return;
   }
   
   switch( event_type )
   {
    case GLG.GlgEventType.TOUCH_START:
    case GLG.GlgEventType.MOUSE_PRESSED:
      if( ZoomToMode() )
        return;  // ZoomTo or dragging mode in progress.
        
      /* Start dragging with the mouse on a mouse click. 
         If user clicked on an axis, the dragging will be activated in the
         direction of that axis. If the user clicked in the chart area,
         dragging in both the time and the Y direction will be activated. 
      */
      ChartVP.SetZoom( null, 's', 0.0 );
        
      // Disable AutoScroll not to interfere with dragging.
      ChangeAutoScroll( 0 ); 
      break;
        
    default: return;
   }
}

//////////////////////////////////////////////////////////////////////////////
// Change chart's AutoScroll mode.
//////////////////////////////////////////////////////////////////////////////
function ChangeAutoScroll( /*int*/ new_value )
{
   if( new_value == -1 )  // Use the state of the ToggleAutoScroll button.
   {
      AutoScroll = 
        Math.trunc( Toolbar.GetDResource( "ToggleAutoScroll/OnState" ) );
   }
   else    // Set to the supplied value. 
   {
      AutoScroll = new_value;
      Toolbar.SetDResource( "ToggleAutoScroll/OnState", AutoScroll );
   }
    
   // Set chart's auto-scroll.
   Chart.SetDResource( "AutoScroll", AutoScroll );
    
   /* Activate time scrollbar if AutoScroll is Off. The Y value scrollbar 
      uses GLG_PAN_Y_AUTO and appears automatically as needed.
   */
   var pan_x =    /* int */
     ( AutoScroll != 0 ? GLG.GlgPanType.NO_PAN : GLG.GlgPanType.PAN_X );
    
   ChartVP.SetDResource( "Pan", ( pan_x | GLG.GlgPanType.PAN_Y_AUTO ) );
}
//////////////////////////////////////////////////////////////////////////////
// Changes the time span shown in the graph, adjusts major and minor tick 
// intervals to match the time span.
//////////////////////////////////////////////////////////////////////////////
function SetChartSpan( /*int*/ span_index )
{
   var span, major_interval, minor_interval;   /* int */
    
   /* Change chart's time span, as well as major and minor tick intervals.*/
   switch( span_index )
   {
    default:
    case 0:
      span = ONE_MINUTE;
      major_interval = 10;  /* major tick every 10 sec. */
      minor_interval = 1;   /* minor tick every sec. */
      break;
        
    case 1:
      span = 10 * ONE_MINUTE;
      major_interval = ONE_MINUTE * 2; /* major tick every tow minutes. */
      minor_interval = 30;             /* minor tick every 30 sec. */
      break;
        
    case 2:
      span = ONE_HOUR;
      major_interval = ONE_MINUTE * 10; /* major tick every 10 min. */
      minor_interval = ONE_MINUTE;      /* minor tick every min. */
      break;

    case 3:
      span = ONE_HOUR * 8;
      major_interval = ONE_HOUR;        /* major tick every hour. */
      minor_interval = ONE_MINUTE * 15; /* minor tick every 15 minutes. */
      break;
   }
    
   /* Update the menu in the drawing with the initial value if different. */
   Toolbar.SetDResourceIf( "SpanSelector/SelectedIndex", 
                           span_index, true );
        
   /* Set intervals before SetZoom() below to avoid redrawing huge number 
      of labels. 
   */
   Chart.SetDResource( "XAxis/MajorInterval", major_interval );
   Chart.SetDResource( "XAxis/MinorInterval", minor_interval );
    
   /* Set the X axis span which controls how much data is displayed in the 
      chart. 
   */
   TimeSpan = span;
   Chart.SetDResource( "XAxis/Span", TimeSpan );
    
   /* Turn on data filtering for large spans. FilterType and FilterPrecision
      attributes of all plots are constrained, so that they may be set in one
      place, on one plot.
   */
   if( span_index > 1 )
   {
      /* Agregate multiple data samples to minimize a number of data points 
         drawn per each horizontal FilterPrecision interval.
         Show only one set of MIN/MAX values per each pixel interval. 
         An averaging data filter is also available.
      */
      PlotArray[0].plot.SetDResource( "FilterType", 
                                      GLG.GlgChartFilterType.MIN_MAX_FILTER );
      PlotArray[0].plot.SetDResource( "FilterPrecision", 1.0 );
   }
   else
     PlotArray[0].plot.SetDResource( "FilterType", 
                                     GLG.GlgChartFilterType.NULL_FILTER );
    
   /* Change time and tooltip formatting to match the selected span. */
   SetTimeFormats();
}

//////////////////////////////////////////////////////////////////////////////
// Sets the formats of time labels and tooltips depending on the selected 
// time span.
//////////////////////////////////////////////////////////////////////////////
function SetTimeFormats()
{
   var 
     time_label_format,           /* String */
     time_tooltip_format,         /* String */
     chart_tooltip_format;        /* String */

   /* No additional code is required to use the default settings defined 
      in the drawing. The code below illustrates advanced options for 
      customizing label and tooltip formatting when switching between 
      time spans and data display modes.
       
      For an even greater control over labels and tooltips, an application 
      can define custom Label and Tooltip formatters that will supply 
      custom strings for axis labels and tooltips.
   */
    
   /* Different time formats are used depending on the selected
      time span. See strftime() for all time format options.
   */
   switch( SpanIndex )
   {
    default:  /* 1 minute and 10 minutes spans */
      /* Use the preferred time and date display format for the current 
         locale. 
      */
      time_label_format = "%X%n%x";
      break;
        
    case 2: /* 1 hour span */
      /* Use the 12 hour time display with no seconds, and the default 
         date display format for the current locale.
      */
      time_label_format = "%I:%M %p%n%x";
      break;
        
    case 3: /* 1 hour and 8 hour spans */
      /* Use 24 hour notation and don't display seconds. */
      time_label_format = "%H:%M%n%x";
      break;
   }
    
   Chart.SetSResource( "XAxis/TimeFormat", time_label_format );
    
   /* Specify axis and chart tooltip format, if different from default 
      formats defined in the drawing.
   */
   time_tooltip_format = 
     "Time: <axis_time:%X> +0.<axis_time_ms:%03.0lf> sec.\nDate: <axis_time:%x>";
    
   /* <sample_time:%s> inherits time format from the X axis. */
   chart_tooltip_format = 
     "Plot <plot_string:%s> value= <sample_y:%.2lf>\n<sample_time:%s>";
    
   /* Set time label and tooltip formats. */
   Chart.SetSResource( "XAxis/TooltipFormat", time_tooltip_format );
   Chart.SetSResource( "TooltipFormat", chart_tooltip_format );
}

//////////////////////////////////////////////////////////////////////////////
// Scrolls the chart to the minimum or maximum time stamp to show the 
// most recent or the least recent data. If show_extra is True, adds a 
// few extra seconds in the real-time mode to show a few next updates
// without scrolling the chart.
//
// Enabling AutoScroll automatically scrolls the chart to show current 
// data points when the new time stamp is more recent then the EndValue 
// of the axis, but it is not the case when the chart is scrolled into 
// the future (to the right) - still need to invoke this method.
//////////////////////////////////////////////////////////////////////////////
function ScrollToDataEnd( /*int*/ data_end, /*boolean*/ show_extra_sec )
{
   var end_value, extra_sec;   /* double */
    
   if( data_end == DONT_CHANGE )
     return;
    
   // Get the min and max time stamp.
   var min_max =   /* GlgMinMax */
     Chart.GetChartDataExtent( null, /* x extent */ true,
                               /*query all samples*/ false );
   if( min_max == null )
     return;
    
   if( show_extra_sec )   
     extra_sec = GetExtraSeconds();
   else
     extra_sec = 0.0;
    
   if( data_end == MOST_RECENT )
     end_value = min_max.max + extra_sec;
   else   /* LEAST_RECENT */
     end_value = min_max.min - extra_sec + this.TimeSpan ;
    
   Chart.SetDResource( "XAxis/EndValue", end_value );
}
   
//////////////////////////////////////////////////////////////////////////////
// Restore Y axis range to the initial Low/High values.
//////////////////////////////////////////////////////////////////////////////
function RestoreInitialYRanges()
{
   var axis_array = 
     Chart.GetResourceObject( "YAxisGroup" ); /* GlgObject */
    
   for( var i=0; i<NumYAxes; ++i )
   {
      var axis = axis_array.GetElement( i );   /* GlgObject */
      axis.SetDResource( "Low", Low[i] );
      axis.SetDResource( "High", High[i] );
   }
}
   
//////////////////////////////////////////////////////////////////////////////
// Returns true if the chart's viewport is in ZoomToMode.
// ZoomToMode is activated on Dragging and ZoomTo operations.
//////////////////////////////////////////////////////////////////////////////
function ZoomToMode()   /* boolean */
{
   var zoom_mode =    /* int */
     Math.trunc( ChartVP.GetDResource( "ZoomToMode" ) );
   return ( zoom_mode != 0 );
}

//////////////////////////////////////////////////////////////////////////////
// Abort ZoomTo mode.
//////////////////////////////////////////////////////////////////////////////
function AbortZoomTo()
{
   if( ZoomToMode() )
   {
      // Abort zoom mode in progress.
      ChartVP.SetZoom( null, 'e', 0.0 ); 
      ChartVP.Update();
   }
}

//////////////////////////////////////////////////////////////////////////////
// Determines a good number of extra seconds to be added at the end in
// the real-time mode to show a few next updates without scrolling the
// chart.
//////////////////////////////////////////////////////////////////////////////
function GetExtraSeconds()   /* double */
{
   var extra_sec, max_extra_sec;   /* double */

   extra_sec = TimeSpan * 0.1;
   max_extra_sec = ( TimeSpan > ONE_HOUR ? 5.0 : 3.0 );

   if( extra_sec > max_extra_sec )
     extra_sec = max_extra_sec;
   
   return extra_sec;
}

//////////////////////////////////////////////////////////////////////////////
// Change drawing size while maintaining width/height aspect ratio.
//////////////////////////////////////////////////////////////////////////////
function SetDrawingSize( next_size )
{
   const ASPECT_RATIO = 700 / 540;
    
   const MIN_WIDTH = 500;
   const MAX_WIDTH = 900;
   const SCROLLBAR_WIDTH = 15;
    
   if( SetDrawingSize.size_index == undefined )   // first time
   {
      SetDrawingSize.size_index = 2;
        
      SetDrawingSize.small_sizes       = [ 1, 1.5,  2.,   2.5 ];
      SetDrawingSize.medium_sizes      = [ 1, 0.75, 1.25, 1.5 ];
      SetDrawingSize.large_sizes       = [ 1, 0.6,  1.25, 1.5 ];
      SetDrawingSize.num_sizes = SetDrawingSize.small_sizes.length;
      SetDrawingSize.is_mobile = ( screen.width <= 760 );
        
      window.addEventListener( "resize", ()=>SetDrawingSize( false ) );
   }
   else if( next_size )
   {
      ++SetDrawingSize.size_index;
      SetDrawingSize.size_index %= SetDrawingSize.num_sizes;
   }
    
   var drawing_area = document.getElementById( "glg_area" );
   
   if( SetDrawingSize.is_mobile )
   {
      /* Mobile devices use constant device-width, adjust only the height 
         of the drawing to keep the aspect ratio.
      */
      drawing_area.style.height =
        "" + Math.trunc( drawing_area.clientWidth / ASPECT_RATIO ) + "px";
   }
   else   /* Desktop */
   {
      var span = document.body.clientWidth; 
      span -= SCROLLBAR_WIDTH;
       
      var start_width;
      if( span < MIN_WIDTH )
        start_width = MIN_WIDTH;
      else if( span > MAX_WIDTH )
        start_width = MAX_WIDTH;
      else
        start_width = span;
       
      var size_array;
      if( span < 600 )
        size_array = SetDrawingSize.small_sizes;
      else if( span < 800 )
        size_array = SetDrawingSize.medium_sizes;
      else
        size_array = SetDrawingSize.large_sizes;
       
      var size_coeff = size_array[ SetDrawingSize.size_index ];
      var width = Math.trunc( Math.max( start_width * size_coeff, MIN_WIDTH ) );
      drawing_area.style.width = "" + 1090 + "px";
      drawing_area.style.height = 
        "" + 653 + "px";
   }
}

//////////////////////////////////////////////////////////////////////////////
// Increases canvas resolution for mobile devices with HiDPI displays.
//////////////////////////////////////////////////////////////////////////////
function SetCanvasResolution()
{
   // Set canvas resolution only for mobile devices with devicePixelRatio != 1.
   if( window.devicePixelRatio == 1. || !SetDrawingSize.is_mobile )
     return;   // Use coord scale = 1.0 for desktop.

   /* The first parameter defines canvas coordinate scaling with values 
      between 1 and devicePixelRatio. Values greater than 1 increase 
      canvas resolution and result in sharper rendering. The value of 
      devicePixelRatio may be used for very crisp rendering with very thin 
      lines.
       
      Canvas scale > 1 makes text smaller, and the second parameter defines
      the text scaling factor used to increase text size.
       
      The third parameter defines the scaling factor that is used to
      scale down text in native widgets (such as native buttons, toggles, etc.)
      to match the scale of the drawing.
   */
   CoordScale = 2.0;
   TextScale = 1.5;
   var native_widget_text_scale = 0.6;
   GLG.SetCanvasScale( CoordScale, TextScale, native_widget_text_scale );
    
   // Mobile devices use fixed device-width: disable Change Drawing Size button.
   var change_size_button = document.getElementById( "change_size" );
   if( change_size_button != null )
     change_size_button.parentNode.removeChild( change_size_button );
}

//////////////////////////////////////////////////////////////////////////////
// Adjust GLG object geometry for mobile devices if needed, using 
// special properties defined in the object.
//////////////////////////////////////////////////////////////////////////////
function AdjustForMobileDevices()
{
   if( CoordScale == 1.0 ) // Desktop, no adjustements needed.
     return;
    
   var result = false;
   result = SetParameter( MainViewport, "Toolbar/XScale", 1.5 );
   result = SetParameter( MainViewport, "Toolbar/YScale", 1.5 ); 
   result = SetParameter( MainViewport, "Toolbar/HeightScale", 1.5 ); 
   result = SetParameter( MainViewport, 
                          "ChartViewport/OffsetCoeffForMobile", 1.2 ); 
}

//////////////////////////////////////////////////////////////////////////////
// Loads any assets required by the application and invokes the specified
// callback when done.
// Alternatively, the application drawing can be loaded as an asset here
// as well, so that it starts loading without waiting for the other assets 
// to finish loading.
//////////////////////////////////////////////////////////////////////////////
function LoadAssets( callback, user_data )
{
   /* HTML5 doesn't provide a scrollbar input element (only a range input 
      html element is available). This application needs to load GLG scrollbars
      used for integrated chart scrolling. For each loaded scrollbar, the 
      AssetLoaded callback is invoked with the supplied data array parameter.
   */    
   GLG.LoadWidgetFromURL( "/RealTimeChart/OpenGL/scrollbar_h.g", null, AssetLoaded,
                          { name: "scrollbar_h", callback: callback,
                               user_data: user_data } );
   GLG.LoadWidgetFromURL( "/RealTimeChart/OpenGL/scrollbar_v.g", null, AssetLoaded,
                          { name: "scrollbar_v", callback: callback,
                               user_data: user_data } );
}

//////////////////////////////////////////////////////////////////////////////
function AssetLoaded( glg_object, data, path )
{
   if( data.name == "scrollbar_h" )
   {
      if( glg_object != null )
        glg_object.SetResourceObject( "$config/GlgHScrollbar", glg_object );
   }
   else if( data.name == "scrollbar_v" )
   {
      if( glg_object != null )
        glg_object.SetResourceObject( "$config/GlgVScrollbar", glg_object );
   }
   else
     console.error( "Unexpected asset name" );

   /* Define an internal variable to keep the number of loaded assets. */
   if( AssetLoaded.num_loaded == undefined )
     AssetLoaded.num_loaded = 1;
   else
     ++AssetLoaded.num_loaded;
    
   /* Invoke the callback (the second parameter of the data array) after all
      assets have been loaded.
   */
   if( AssetLoaded.num_loaded == 2 )
     data.callback( data.user_data );
}

//////////////////////////////////////////////////////////////////////////
// Sets a D parameter of the specified object to the specified value.
// Returns false if the specified resource is not present.
// Returns true on success.
//////////////////////////////////////////////////////////////////////////
function SetParameter( /*GlgObject*/ object, 
                       /*String*/ res_name, /*double*/ value ) /* boolean */
{
   var res_obj = object.GetResourceObject( res_name );
   if( res_obj == null )
     return false;

   return res_obj.SetDResourceIf( null, value, /*if_changed*/ true );
}

//////////////////////////////////////////////////////////////////////////////
function IsUndefined( /*String*/ str )  /* boolean */
{
   return ( str == null || str.length == 0 || 
            str == "unset" || str == "$unnamed" );
}

//////////////////////////////////////////////////////////////////////////
function GetCurrTime()
{
   return Date.now() / 1000;    // seconds
} 

//////////////////////////////////////////////////////////////////////////////
function Debug( message )
{
   if( DEBUG )
     console.log( message );
}

//////////////////////////////////////////////////////////////////////////////
function AppError( message )
{
   console.error( message );
}

//////////////////////////////////////////////////////////////////////////////
function AppAlert( message )
{
   window.alert( message );
}

//////////////////////////////////////////////////////////////////////////////
// Used to store and pass information about one data sample.
// Set SUPPLY_TIME_STAMP=true to supply time_stamp explicitly. 
// Otherwise, the chart will automatically display a time stamp 
// using current time.
//////////////////////////////////////////////////////////////////////////////
function PlotDataPoint( /*double*/ value, /*double*/ time_stamp,
                        /*boolean*/ value_valid )
{
   this.value = value;
   this.time_stamp = time_stamp;
   this.value_valid = value_valid;
}

//////////////////////////////////////////////////////////////////////////////
// Used to store information about each plot in a chart.
//////////////////////////////////////////////////////////////////////////////
function PlotInfo( /*GlgObject*/ plot, /*GlgObject*/ value_ep, 
                   /*GlgObject*/ time_ep, /*GlgObject*/ valid_ep, 
                   /*String*/ tag_source )
{
   this.plot = plot;                   /* Plot object:      GlgObject */
   this.value_ep = value_ep;           /* ValueEntryPoint:  GlgObject */
   this.time_ep = time_ep;             /* TimeEntryPoint:   GlgObject */
   this.valid_ep = valid_ep;           /* ValidEntryPoint:  GlgObject */

   /* TagSource assigned to ValueEntryPoint. Represents a data source variable
      in the back-end system to get the real-time value from for this plot.
   */
   this.tag_source = tag_source;       /* String */
}
